# 什么时候该"大前端"，什么时候该老老实实写原生

> **TL;DR**：大前端不是"前端无所不能"，而是"有节制地扩展边界"。核心原则：**高频迭代用跨端，核心体验用原生**。本文提供一个可操作的决策框架，帮你在具体场景中做出选择。

---

## 一、一个真实的困惑

"这个需求用H5做还是原生做？"

如果你是前端或客户端开发，这个问题你一定被问过无数次。产品经理问你，你可能也问过自己。

答案往往是："看情况。"

但"看情况"三个字背后，藏着一套完整的决策逻辑。很多人凭感觉回答，有时候选对了，有时候选错了，事后复盘也说不清楚为什么。

今天这篇文章，我想把这套决策逻辑讲清楚。

在聊具体选择之前，我们先澄清一个被严重误解的概念——"大前端"。

---

## 二、概念澄清：大前端到底是什么

### 三个常见误解

| 误解 | 真相 |
|---|---|
| 大前端 = 前端什么都做 | ❌ 大前端有边界，不是无限扩张 |
| 大前端 = 一套代码跑所有端 | ❌ 这是跨端框架的目标，不是大前端的定义 |
| 大前端 = 组建一个"大前端部" | ❌ 组织合并多数失败，这不是大前端的核心 |

### 那大前端到底是什么？

**大前端 = 用前端技术栈（JS/TS生态）触达多个端 + 跨端的技术共享机制**

注意两个关键点：
1. **"触达多端"**：浏览器、App内H5、小程序、桌面应用...
2. **"共享机制"**：组件库、工程工具、技术规范、选型决策

大前端不是要把所有端都用一种技术实现，而是在**合适的场景**用**合适的技术**，同时尽可能**复用**能复用的部分。

### 大前端的边界

```
┌─────────────────────────────────────────────────────────────┐
│                        大前端的触达范围                      │
│                                                             │
│   ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐       │
│   │ 浏览器  │  │ App内H5 │  │ 小程序  │  │ 桌面应用 │       │
│   │  Web    │  │ Hybrid  │  │ 微信等  │  │Electron │       │
│   └─────────┘  └─────────┘  └─────────┘  └─────────┘       │
│        ↑            ↑            ↑            ↑            │
│        └────────────┴─────┬──────┴────────────┘            │
│                           │                                 │
│              JS/TS 技术栈 + 共享组件/工具                    │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                    大前端的边界之外                          │
│                                                             │
│   ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐       │
│   │ 原生iOS │  │原生安卓 │  │ 游戏引擎│  │ 嵌入式  │       │
│   │ Swift   │  │ Kotlin  │  │ Unity   │  │   C     │       │
│   └─────────┘  └─────────┘  └─────────┘  └─────────┘       │
└─────────────────────────────────────────────────────────────┘
```

大前端和原生开发不是对立关系，而是**互补关系**。一个成熟的App，往往是两者的混合体。

---

## 三、组织层面：为什么"大前端部"多数失败了

在聊技术选型之前，我想先聊聊组织层面的问题。因为很多公司对"大前端"的第一反应是：把前端和客户端合并成一个部门。

**这条路，业界已经替我们踩过坑了。**

### 康威定律的反噬

康威定律说：**系统的设计反映了组织的沟通结构**。

反过来理解：如果你强行合并组织，但底层技术栈差异很大，就会产生问题。

| 问题 | 具体表现 |
|---|---|
| **技能差异** | Web前端写React，iOS写Swift，Android写Kotlin。三套技能树，互相"带不动" |
| **绩效评估** | 怎么评价一个"既写React又写Swift"的人？和专精一个方向的人怎么比？ |
| **招聘困难** | "大前端工程师"这个岗位JD怎么写？要求太广招不到人，要求太窄又不符合"大前端"定位 |
| **深度缺失** | 什么都会一点，但哪个方向都不精通 |

### 业界的实际做法

我观察到的三种模式：

**模式A：完全合并（少见，多数失败）**

把Web前端、iOS、Android合并成一个部门。听起来很美好，实际执行困难重重。大部分尝试过的公司后来又拆开了。

**模式B：虚拟团队（常见，效果较好）**

各端保持独立团队，但成立一个虚拟的"大前端技术委员会"，负责：
- 共享组件库的建设
- 跨端技术规范的制定
- 工程工具的统一
- 技术选型的决策

**模式C：按业务垂直切分（头部大厂主流）**

按业务线划分团队，每个业务团队里包含产品、前端、客户端、后端。各端开发在同一业务团队，向业务目标负责。

### 核心观点

> **大前端的价值在于"技术共享"，不在于"组织合并"。**

共享什么？
- 共享组件库（跨端通用组件）
- 共享工程基建（CI/CD、监控、埋点）
- 共享技术规范（代码风格、API设计）
- 共享决策机制（什么场景用什么技术）

不需要把人合并到一起，需要的是**建立协作机制**。

---

## 四、技术层面：业界到底怎么选的

### 跨端技术的演进

| 阶段 | 年份 | 代表技术 | 现状 |
|---|---|---|---|
| Hybrid 1.0 | 2010-2014 | Cordova/PhoneGap | 基本淘汰 |
| Hybrid 2.0 | 2014-至今 | WebView + 深度定制 | 仍广泛使用 |
| 跨端框架 | 2015-至今 | React Native、Weex | RN仍有市场，Weex基本凉了 |
| 自绘引擎 | 2018-至今 | Flutter | 增长最快 |
| 小程序 | 2017-至今 | 微信/支付宝小程序 | 独立生态，必须支持 |
| DSL编译 | 2018-至今 | Taro、uni-app | 主打一套代码多端 |

### 大厂的真实选型

没有一家大厂"全部用一种技术"。看看他们怎么选的：

| 公司 | 技术选型 | 特点 |
|---|---|---|
| **美团** | RN + Native + H5 混合 | 按场景选技术，不追求统一 |
| **字节** | Flutter + Lynx（自研） | 重投入自研，解决Flutter的问题 |
| **阿里** | 各BU各自选型 | Weex式微后没有统一技术栈 |
| **腾讯** | 小程序生态为主 | 微信生态内闭环 |
| **京东** | Taro（自研）+ RN | 开源Taro，主打编译时跨端 |

### 一个朴素的原则

业界的共识可以总结为一句话：

> **核心路径用原生，非核心路径用跨端/H5。**

什么是"核心路径"？用户最在意体验的地方：
- App启动流程
- 高频使用的主界面（首页、Tab框架）
- 复杂的手势交互和动画
- 音视频/直播等性能敏感场景

> **注意**：交易流程（商品详情、下单、确认）其实可以用H5，只有"调起支付SDK"这一步需要原生能力（通过JSBridge调用）。业界大厂的交易页面大量使用H5，这样能快速迭代。

什么是"非核心路径"？可以容忍一定体验折损的地方：
- 活动页、营销页
- 帮助中心、设置页
- 低频使用的功能
- 需要快速迭代的运营位

一个典型App的技术分布：

```
┌─────────────────────────────────────────────────────────┐
│                      一个典型App                        │
├───────────────────────┬─────────────────────────────────┤
│      核心体验区       │          可变内容区             │
│       (原生)          │         (H5/跨端)               │
├───────────────────────┼─────────────────────────────────┤
│ • 首页框架            │ • 活动页/营销页                 │
│ • 启动流程            │ • 商品详情                      │
│ • Tab切换/导航        │ • 交易流程（下单、确认）        │
│ • 复杂手势/动画       │ • 帮助中心/设置页               │
│ • 音视频/直播         │ • 运营Banner                    │
│ • 支付SDK调起         │ • 个人中心部分页面              │
└───────────────────────┴─────────────────────────────────┘
```

> **关键区分**：交易流程的"内容页面"可以用H5快速迭代，只有"调起支付SDK"这一步需要原生。通过JSBridge，H5页面可以无缝调起微信支付、支付宝等原生支付能力。

---

## 五、决策框架：什么场景用什么技术

说了这么多，到底怎么判断一个具体需求用什么技术？

我总结了四个评估维度：

### 维度一：迭代频率

| 迭代频率 | 推荐方案 | 原因 |
|---|---|---|
| 高频（每周甚至每天） | H5 / 小程序 | 热更新，不依赖App发版 |
| 中频（每月） | 跨端框架（RN/Flutter） | 有一定热更新能力 |
| 低频（跟随App版本） | 原生 | 体验最好，维护成本可控 |

**判断方法**：问自己——这个功能上线后，多久会改一次？

### 维度二：体验要求

| 体验要求 | 推荐方案 | 原因 |
|---|---|---|
| 极高（用户敏感） | 原生 | 流畅度、响应速度最好 |
| 中等（可接受轻微延迟） | 跨端框架 | 接近原生，开发效率高 |
| 一般（内容展示为主） | H5 | 开发最快，够用就行 |

**判断方法**：问自己——用户会不会因为这个页面"卡一下"就骂产品？

### 维度三：原生能力依赖

| 原生能力依赖 | 推荐方案 | 原因 |
|---|---|---|
| 重度依赖（相机、蓝牙、传感器） | 原生 | 跨端框架能力有限 |
| 中度依赖（定位、推送、分享） | 跨端框架 + Bridge | 通用能力有成熟方案 |
| 轻度依赖（纯展示） | H5 | 不需要原生能力 |

**判断方法**：列出这个功能需要调用的原生API，越多越倾向原生。

### 维度四：团队能力和维护成本

| 团队情况 | 推荐方案 | 原因 |
|---|---|---|
| 有成熟的原生团队 | 原生 | 发挥现有优势 |
| 有跨端框架经验 | 跨端框架 | 已踩过坑，风险可控 |
| 纯Web前端团队 | H5 / 小程序 | 学习成本最低 |

**判断方法**：团队最擅长什么？不要为了"先进"而用不熟悉的技术。

### 决策矩阵

把四个维度综合起来，可以得到一个简单的决策矩阵：

| 场景 | 迭代频率 | 体验要求 | 原生依赖 | 推荐方案 |
|---|---|---|---|---|
| 首页/Tab主框架 | 低 | 极高 | 中 | **原生** |
| 交易流程（下单、确认） | 高 | 中 | 低 | **H5**（支付调原生SDK） |
| 活动/营销页 | 极高 | 一般 | 低 | **H5** |
| 商品详情页 | 中 | 中 | 低 | **H5 或 跨端** |
| 直播/音视频 | 低 | 极高 | 重 | **原生** |
| 设置/帮助页 | 低 | 一般 | 低 | **H5** |
| IM聊天界面 | 中 | 高 | 中 | **跨端 或 原生** |
| 支付SDK调起 | 低 | 高 | 重 | **原生**（通过JSBridge） |

### 一个快速判断的口诀

> **"高频H5，框架原生，调能力用Bridge。"**

---

## 六、反思：大前端的边界在哪里

### 什么场景不应该"跨端"

有些场景，就是不适合用跨端技术，硬上只会踩坑：

| 场景 | 原因 | 建议 |
|---|---|---|
| 高性能游戏 | 帧率要求高，需要GPU直接控制 | 用Unity/Unreal |
| 复杂动画/特效 | 跨端框架渲染性能有限 | 原生实现 |
| 音视频处理 | 编解码、实时处理对性能敏感 | 原生 + 专业SDK |
| 极致启动速度 | 跨端框架有JS引擎初始化开销 | 原生 |
| 深度系统集成 | Widget、快捷指令、系统级能力 | 原生 |

**核心判断**：如果这个功能对性能/体验的要求已经到了"毫秒级优化"的程度，就别折腾跨端了。

### 跨端的隐性成本

跨端技术看起来"一套代码多端运行"很美好，但隐性成本往往被低估：

| 宣传的好处 | 实际的代价 |
|---|---|
| 一套代码 | 需要大量条件编译和平台适配代码 |
| 降低人力 | 需要更高水平的工程师处理多端差异 |
| 接近原生 | 某些场景确实接近，某些场景差距明显 |
| 快速迭代 | 框架本身的Bug和版本升级也是成本 |
| 技术统一 | 绑定特定框架，迁移成本高 |

**真实故事**：某团队用RN重写了App的核心流程，开发确实快了。但两年后RN大版本升级，适配花了三个月，期间新功能开发几乎停滞。

### 平衡之道

我的建议是：

1. **不要追求"全部跨端"**——混合架构才是常态
2. **先小范围试点**——用非核心功能验证技术可行性
3. **建立撤退机制**——如果跨端方案不行，能快速切回原生吗？
4. **关注框架生命周期**——选择活跃维护的技术，避免"框架凉了"的风险

---

## 七、结语

回到开头的问题："这个需求用H5做还是原生做？"

现在你应该有一个更清晰的判断框架了：

### 核心认知

1. **大前端不是"前端万能"**——它是有边界的扩展
2. **组织合并不是大前端的核心**——技术共享才是
3. **没有银弹**——按场景选技术是唯一正确答案
4. **框架用原生，内容用H5，调能力用Bridge**——这才是业界实际做法

### 可带走的判断标准

问自己四个问题：

1. **这个功能多久改一次？** → 高频用H5
2. **用户对体验多敏感？** → 框架/动画敏感用原生
3. **需要调用原生能力吗？** → 用JSBridge调用，不用整个页面原生
4. **团队擅长什么？** → 发挥现有优势

### 最后一句话

> **一个App里，有些地方用原生，有些地方用H5，这才是正常的。不用纠结"统一技术栈"，混着用就对了。**

---

*如果这篇文章对你有帮助，欢迎分享给同样困惑的同事。*

