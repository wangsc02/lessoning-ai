# Generate Learning Document (生成学习文档｜一键版)

> **使用说明**：一个命令完成“生成 + 自检 +（可选）最终校对”。如需更高质量，你可以在指定节点手动切换模型（Cursor 无法自动换模型）。

## 📋 工作流程（单命令内完成）

```
生成终稿（一次性） → 自检修订（同一条回复内） →（可选）最终校对
```

---

## 任务：根据你给的内容，生成一份“可复用”的学习文档

**推荐模型（非强制）**：
- 初稿：GPT-5.2（结构/速度）或 Sonnet 4.5（叙事/解释）
- 终稿校对：Sonnet 4.5（更稳）
- 超长文本整合：Gemini 3 Pro（如果你一次性贴了非常长的材料）

### 任务描述

根据用户提供的原始内容，生成一份结构化的学习文档，并完成自检与校对。

### 输出要求

1. **标题**：简洁有力，能概括核心主题
2. **TL;DR**：一句话总结文档价值
3. **结构**：
   - 引言（痛点/场景）
   - 核心概念（类比 + 技术本质）
   - 多维度对比（5-7个维度）
   - 实战案例（至少3个）
   - 决策框架（可快速查阅）
   - 深刻认知（3-5条）
   - 行动建议
4. **风格**：
   - 第一人称叙述（"我花了一周时间..."）
   - 类比丰富（厨师、餐厅、团队等生活化场景）
   - 代码块尽量短（建议≤25行），优先“关键片段 + 解释”，伪代码必须标注 `(Pseudocode)`
   - 表格清晰
   - 适当使用 ✅❌ 等符号
5. **深度**（必须满足）：
   - 关键观点必须写清“前提/边界条件”
   - 至少给出 2 个反例/误区（反模式）
   - 结论尽量落到可验证的 checklist / 决策问题 / 验收标准

### 执行步骤

#### 第一步：直接生成终稿（不需要任何确认）
1. 不输出大纲；直接生成可发布的完整 Markdown 学习文档。
2. 若用户输入信息不足，**默认采用**：工程师读者、偏生产落地、通用技术栈；并在文末用“假设/边界条件”列出这些默认项（方便用户后续再改）。
3. 文档必须满足 Rule 的“深度要求”（机制/思维模型、边界条件、深刻认知、可验证 checklist、读者分层），并控制代码块篇幅（建议≤25行）。

#### 第二步：自检修订（在同一条回复中完成）
按 `.cursor/rules/technical-writing-quality.mdc` 的检查项自检：
- 标题/正文一致性、术语统一、是否出现绝对化表述
- 代码块是否短小、伪代码是否标注
- 是否给出反例/误区与可验证 checklist
对发现的问题直接修订正文后再输出终稿。

#### 第三步：最终校对（可选手动换模型）
如果你愿意在这里切换到 Sonnet 4.5：请切换后继续说“继续最终校对”，我会做一轮更苛刻的逻辑/措辞/一致性校正。

### 注意事项

- **不要**生成空泛的内容（"这是一个很重要的话题..."）
- **不要**使用过多术语（如果必须用，要解释）
- **不要**省略具体示例（每个维度都要有代码/场景）
- **确保**技术表述准确（如"注入到指令/上下文"而非"注入到 System Prompt"）

---

## 用户输入区

**请在下方提供你的原始内容**（可以是要点、草稿、聊天记录、链接摘要）：

{用户会在这里粘贴他的想法、笔记、或者想要生成文档的主题}

